.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "BN_generate_prime 3"
.TH BN_generate_prime 3 2015-06-11 0.9.8zg OpenSSL
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
BN_generate_prime, BN_is_prime, BN_is_prime_fasttest \- generate primes and test for primality
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bn.h>
\&
\& BIGNUM *BN_generate_prime(BIGNUM *ret, int num, int safe, BIGNUM *add,
\&     BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg);
\&
\& int BN_is_prime(const BIGNUM *a, int checks, void (*callback)(int, int, 
\&     void *), BN_CTX *ctx, void *cb_arg);
\&
\& int BN_is_prime_fasttest(const BIGNUM *a, int checks,
\&     void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg,
\&     int do_trial_division);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
\&\fBBN_generate_prime()\fR generates a pseudo-random prime number of \fBnum\fR
bits.
If \fBret\fR is not \fBNULL\fR, it will be used to store the number.
.PP
If \fBcallback\fR is not \fBNULL\fR, it is called as follows:
.IP \(bu 4
\&\fBcallback(0, i, cb_arg)\fR is called after generating the i\-th
potential prime number.
.IP \(bu 4
While the number is being tested for primality, \fBcallback(1, j,
cb_arg)\fR is called as described below.
.IP \(bu 4
When a prime has been found, \fBcallback(2, i, cb_arg)\fR is called.
.PP
The prime may have to fulfill additional requirements for use in
Diffie-Hellman key exchange:
.PP
If \fBadd\fR is not \fBNULL\fR, the prime will fulfill the condition p % \fBadd\fR
== \fBrem\fR (p % \fBadd\fR == 1 if \fBrem\fR == \fBNULL\fR) in order to suit a given
generator.
.PP
If \fBsafe\fR is true, it will be a safe prime (i.e. a prime p so
that (p\-1)/2 is also prime).
.PP
The PRNG must be seeded prior to calling \fBBN_generate_prime()\fR.
The prime number generation has a negligible error probability.
.PP
\&\fBBN_is_prime()\fR and \fBBN_is_prime_fasttest()\fR test if the number \fBa\fR is
prime.  The following tests are performed until one of them shows that
\&\fBa\fR is composite; if \fBa\fR passes all these tests, it is considered
prime.
.PP
\&\fBBN_is_prime_fasttest()\fR, when called with \fBdo_trial_division == 1\fR,
first attempts trial division by a number of small primes;
if no divisors are found by this test and \fBcallback\fR is not \fBNULL\fR,
\&\fBcallback(1, \-1, cb_arg)\fR is called.
If \fBdo_trial_division == 0\fR, this test is skipped.
.PP
Both \fBBN_is_prime()\fR and \fBBN_is_prime_fasttest()\fR perform a Miller-Rabin
probabilistic primality test with \fBchecks\fR iterations. If
\&\fBchecks == BN_prime_checks\fR, a number of iterations is used that
yields a false positive rate of at most 2^\-80 for random input.
.PP
If \fBcallback\fR is not \fBNULL\fR, \fBcallback(1, j, cb_arg)\fR is called
after the j\-th iteration (j = 0, 1, ...). \fBctx\fR is a
pre-allocated \fBBN_CTX\fR (to save the overhead of allocating and
freeing the structure in a loop), or \fBNULL\fR.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBBN_generate_prime()\fR returns the prime number on success, \fBNULL\fR otherwise.
.PP
\&\fBBN_is_prime()\fR returns 0 if the number is composite, 1 if it is
prime with an error probability of less than 0.25^\fBchecks\fR, and
\&\-1 on error.
.PP
The error codes can be obtained by \fBERR_get_error\fR\|(3).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBbn\fR\|(3), \fBERR_get_error\fR\|(3), \fBrand\fR\|(3)
.SH HISTORY
.IX Header "HISTORY"
The \fBcb_arg\fR arguments to \fBBN_generate_prime()\fR and to \fBBN_is_prime()\fR
were added in SSLeay 0.9.0. The \fBret\fR argument to \fBBN_generate_prime()\fR
was added in SSLeay 0.9.1.
\&\fBBN_is_prime_fasttest()\fR was added in OpenSSL 0.9.5.
