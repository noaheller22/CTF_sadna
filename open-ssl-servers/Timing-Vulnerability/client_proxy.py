#!/usr/bin/env python3
import socket, struct, base64, time, hmac
from os import urandom
from hashlib import md5, sha1, sha256
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# Import common helpers
from Tls_helpers import handle_client, Keys

# ---------------- Config ----------------
LISTEN_HOST = "0.0.0.0"
LISTEN_PORT = 6000
REAL_SERVER_HOST = "127.0.0.1"
REAL_SERVER_PORT = 5002



# ---------------- Proxy handler ----------------
def handle_player(conn, addr):
    try:
        data = conn.recv(4096).strip()
        ciphertext = base64.b64decode(data)

        real = socket.create_connection((REAL_SERVER_HOST, REAL_SERVER_PORT))

        client_random = urandom(32)
        client_hello = build_client_hello(client_random)
        real.sendall(client_hello)

        server_random = None
        handshake = b""
        rec_count = 0
        while True:
            ctype, version, length, body = recv_tls_message(real)
            rec_count += 1
            handshake += body
            if body[0] == 0x02:
                server_random = body[6:38]
            if body[0] == 0x0e:
                break

        premaster = TLS_VERSION + urandom(46)
        master_secret = tls_prf(premaster, b"master secret", client_random + server_random, 48)
        key_block = tls_prf(master_secret, b"key expansion", server_random + client_random, 104)
        keys = Keys(key_block)

        client_key_exchange = build_client_key_exchange(ciphertext)
        change_cipher_spec = build_change_cipher_spec()
        finished = build_finished(master_secret, keys, client_hello[5:] + handshake + client_key_exchange[5:])

        start = time.perf_counter()
        real.sendall(client_key_exchange)
        real.sendall(change_cipher_spec)
        real.sendall(finished)
        response = real.recv(4096)
        end = time.perf_counter()

        # ---- Dump excessive debug info ----
        conn.sendall(b"[DEBUG] Raw server response: " + response + b"\n")
        conn.sendall(f"[DEBUG] RTT: {(end-start)*1000:.3f} ms\n".encode())
        conn.sendall(f"[DEBUG] Response length: {len(response)} bytes\n".encode())
        conn.sendall(f"[DEBUG] Record count seen in handshake: {rec_count}\n".encode())
        conn.sendall(f"[DEBUG] SHA256(server response): {sha256(response).hexdigest()}\n".encode())
        conn.sendall(f"[DEBUG] Byte histogram: { {b:response.count(b) for b in set(response)} }\n".encode())
        conn.sendall(f"[DEBUG] Client random (hex): {client_random.hex()}\n".encode())
        conn.sendall(f"[DEBUG] Server random (hex): {server_random.hex()}\n".encode())

        if len(response) >= 7 and response[0] == 0x15:  # Alert
            version_major, version_minor = response[1], response[2]
            length = struct.unpack(">H", response[3:5])[0]
            level = response[5]
            levels = {1: "warning", 2: "fatal"}
            desc = response[6]
            conn.sendall(
                f"[DEBUG] Parsed TLS Alert -> version={version_major}.{version_minor}, "
                f"length={length}, level={levels.get(level, level)}, description={desc}\n".encode()
            )
        elif response == b"OK\n":
            conn.sendall(b"[DEBUG] Parsed Response -> Handshake complete (OK)\n")

    except Exception as e:
        conn.sendall(f"[ERROR] {e}\n".encode())
    finally:
        conn.close()

def main():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((LISTEN_HOST, LISTEN_PORT))
    sock.listen(5)
    print(f"[*] Proxy Oracle listening on {LISTEN_HOST}:{LISTEN_PORT}, forwarding to {REAL_SERVER_HOST}:{REAL_SERVER_PORT}")
    while True:
        conn, addr = sock.accept()
        handle_player(conn, addr)

if __name__ == "__main__":
    main()
