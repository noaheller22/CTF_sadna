#!/usr/bin/env python3
import socket, struct, base64, time, hmac
from os import urandom
from hashlib import md5, sha1, sha256
from Crypto.Cipher import AES

# ---------------- Config ----------------
LISTEN_HOST = "0.0.0.0"
LISTEN_PORT = 6000
REAL_SERVER_HOST = "127.0.0.1"
REAL_SERVER_PORT = 5001

TLS_VERSION = b"\x03\x01"
CIPHER_SUITE_ID = 0x002f
BLOCK_SIZE = 16
SEQUENCE_NUMBER = 3

# ---------------- TLS helpers ----------------
def p_hash(hash_mod, secret: bytes, seed: bytes, size: int):
    result = b""
    A = seed
    while len(result) < size:
        A = hmac.new(secret, A, hash_mod).digest()
        result += hmac.new(secret, A + seed, hash_mod).digest()
    return result[:size]

def tls_prf(secret: bytes, label: bytes, seed: bytes, size: int) -> bytes:
    half_length = (len(secret) + 1) // 2
    s1, s2 = secret[:half_length], secret[-half_length:]
    md5_bytes = p_hash(md5, s1, label + seed, size)
    sha1_bytes = p_hash(sha1, s2, label + seed, size)
    return bytes(x ^ y for x, y in zip(md5_bytes, sha1_bytes))

def recv_full(sock, n):
    buf = b""
    while len(buf) < n:
        chunk = sock.recv(n - len(buf))
        if not chunk:
            raise RuntimeError("Socket closed")
        buf += chunk
    return buf

def recv_tls_message(sock: socket.socket):
    header = recv_full(sock, 5)
    ctype = header[0]
    version = header[1:3]
    length = struct.unpack(">H", header[3:5])[0]
    body = recv_full(sock, length)
    return ctype, version, length, body

# ---------------- TLS builders ----------------
def build_client_hello(client_random: bytes) -> bytes:
    session_id = b"\x00"
    cipher_suites = struct.pack(">H", CIPHER_SUITE_ID)
    compression_methods = b"\x01\x00"
    body = TLS_VERSION + client_random + session_id + struct.pack(">H", len(cipher_suites)) + cipher_suites + compression_methods
    handshake = b"\x01" + struct.pack(">I", len(body))[1:] + body
    return b"\x16" + TLS_VERSION + struct.pack(">H", len(handshake)) + handshake

def build_client_key_exchange(ciphertext: bytes) -> bytes:
    body = struct.pack(">H", len(ciphertext)) + ciphertext
    handshake = b"\x10" + struct.pack(">I", len(body))[1:] + body
    return b"\x16" + TLS_VERSION + struct.pack(">H", len(handshake)) + handshake

def build_change_cipher_spec() -> bytes:
    return b"\x14" + TLS_VERSION + struct.pack(">H", 1) + b"\x01"

def build_finished(master_secret: bytes, keys, prev_handshakes: bytes) -> bytes:
    handshake_hash = md5(prev_handshakes).digest() + sha1(prev_handshakes).digest()
    verify_data = tls_prf(master_secret, b"client finished", handshake_hash, 12)
    hs_sig = b"\x14" + len(verify_data).to_bytes(3, "big") + verify_data
    mac_input = SEQUENCE_NUMBER.to_bytes(8, "big") + bytes([0x16]) + TLS_VERSION + len(hs_sig).to_bytes(2, "big") + hs_sig
    mac = hmac.new(keys.client_mac_key, mac_input, sha1).digest()
    plaintext = hs_sig + mac
    pad_len = BLOCK_SIZE - (len(plaintext) % BLOCK_SIZE)
    if pad_len > 0:
        plaintext += bytes([pad_len - 1]) * pad_len
    cipher = AES.new(keys.client_write_key, AES.MODE_CBC, keys.client_initialization_vector)
    encrypted = cipher.encrypt(plaintext)
    return b"\x16" + TLS_VERSION + len(encrypted).to_bytes(2, "big") + encrypted

class Keys:
    def __init__(self, key_block: bytes):
        self.client_mac_key = key_block[:20]
        self.server_mac_key = key_block[20:40]
        self.client_write_key = key_block[40:56]
        self.server_write_key = key_block[56:72]
        self.client_initialization_vector = key_block[72:88]
        self.server_initialization_vector = key_block[88:104]

# ---------------- Proxy handler ----------------
def handle_player(conn, addr):
    try:
        data = conn.recv(4096).strip()
        ciphertext = base64.b64decode(data)

        real = socket.create_connection((REAL_SERVER_HOST, REAL_SERVER_PORT))

        client_random = urandom(32)
        client_hello = build_client_hello(client_random)
        real.sendall(client_hello)

        server_random = None
        handshake = b""
        rec_count = 0
        while True:
            ctype, version, length, body = recv_tls_message(real)
            rec_count += 1
            handshake += body
            if body[0] == 0x02:
                server_random = body[6:38]
            if body[0] == 0x0e:
                break

        premaster = TLS_VERSION + urandom(46)
        master_secret = tls_prf(premaster, b"master secret", client_random + server_random, 48)
        key_block = tls_prf(master_secret, b"key expansion", server_random + client_random, 104)
        keys = Keys(key_block)

        client_key_exchange = build_client_key_exchange(ciphertext)
        change_cipher_spec = build_change_cipher_spec()
        finished = build_finished(master_secret, keys, client_hello[5:] + handshake + client_key_exchange[5:])

        start = time.perf_counter()
        real.sendall(client_key_exchange)
        real.sendall(change_cipher_spec)
        real.sendall(finished)
        response = real.recv(4096)
        end = time.perf_counter()

        # ---- Dump excessive debug info ----
        conn.sendall(b"[DEBUG] Raw server response: " + response + b"\n")
        conn.sendall(f"[DEBUG] RTT: {(end-start)*1000:.3f} ms\n".encode())
        conn.sendall(f"[DEBUG] Response length: {len(response)} bytes\n".encode())
        conn.sendall(f"[DEBUG] Record count seen in handshake: {rec_count}\n".encode())
        conn.sendall(f"[DEBUG] SHA256(server response): {sha256(response).hexdigest()}\n".encode())
        conn.sendall(f"[DEBUG] Byte histogram: { {b:response.count(b) for b in set(response)} }\n".encode())
        conn.sendall(f"[DEBUG] Client random (hex): {client_random.hex()}\n".encode())
        conn.sendall(f"[DEBUG] Server random (hex): {server_random.hex()}\n".encode())

        if len(response) >= 7 and response[0] == 0x15:
            version = response[1:3]
            length = struct.unpack(">H", response[3:5])[0]
            level = response[5]
            desc = response[6]
            conn.sendall(f"[DEBUG] Parsed TLS Alert -> version={version.hex()}, length={length}, level={level}, description={desc}\n".encode())
        elif response == b"OK\n":
            conn.sendall(b"[DEBUG] Parsed Response -> Handshake complete (OK)\n")

    except Exception as e:
        conn.sendall(f"[ERROR] {e}\n".encode())
    finally:
        conn.close()

def main():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((LISTEN_HOST, LISTEN_PORT))
    sock.listen(5)
    print(f"[*] Proxy Oracle listening on {LISTEN_HOST}:{LISTEN_PORT}, forwarding to {REAL_SERVER_HOST}:{REAL_SERVER_PORT}")
    while True:
        conn, addr = sock.accept()
        handle_player(conn, addr)

if __name__ == "__main__":
    main()
