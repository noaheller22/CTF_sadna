#!/usr/bin/env python3
import socket, struct, hmac
from os import urandom
from hashlib import md5, sha1
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.serialization import (
    load_pem_private_key, Encoding, PrivateFormat, NoEncryption
)
from cryptography.hazmat.primitives.asymmetric.padding import PKCS1v15

TLS_VERSION = b"\x03\x01"  # TLS 1.0
CIPHER_SUITE = b"\x00\x2f" # TLS_RSA_WITH_AES_128_SHA
BLOCK_SIZE = 16

CERT_FILE = "server.crt"
KEY_FILE = "server.key"

# ---------------- PRF functions ----------------
def p_hash(hash_mod, secret: bytes, seed: bytes, size: int):
    result = b""
    A = seed
    while len(result) < size:
        A = hmac.new(secret, A, hash_mod).digest()
        result += hmac.new(secret, A + seed, hash_mod).digest()
    return result[:size]

def tls_prf(secret: bytes, label: bytes, seed: bytes, size: int) -> bytes:
    half = (len(secret) + 1) // 2
    s1, s2 = secret[:half], secret[-half:]
    md5_bytes = p_hash(md5, s1, label + seed, size)
    sha1_bytes = p_hash(sha1, s2, label + seed, size)
    return bytes(x ^ y for x, y in zip(md5_bytes, sha1_bytes))

# ---------------- TLS helpers ----------------
def build_server_hello(server_random: bytes) -> bytes:
    session_id = b"\x00"
    comp_methods = b"\x01\x00"
    body = (b"\x02" +
            struct.pack(">I", 38 + 1 + 2 + 1)[1:] +
            TLS_VERSION + server_random + session_id + CIPHER_SUITE + comp_methods)
    return b"\x16" + TLS_VERSION + struct.pack(">H", len(body)) + body

def build_certificate(cert_bytes: bytes) -> bytes:
    cert_list = struct.pack(">I", len(cert_bytes))[1:] + cert_bytes
    all_certs = struct.pack(">I", len(cert_list))[1:] + cert_list
    body = b"\x0b" + struct.pack(">I", len(all_certs))[1:] + all_certs
    return b"\x16" + TLS_VERSION + struct.pack(">H", len(body)) + body

def build_server_hello_done() -> bytes:
    body = b"\x0e\x00\x00\x00"
    return b"\x16" + TLS_VERSION + struct.pack(">H", len(body)) + body

def build_alert(description: int) -> bytes:
    level = 2  # fatal
    payload = bytes([level, description])
    return b"\x15" + TLS_VERSION + struct.pack(">H", len(payload)) + payload

# ---------------- Main TLS logic ----------------
def handle_client(conn, priv_key, cert_bytes):
    try:
        client_hello = conn.recv(4096)
        print("[*] Got ClientHello")

        # send ServerHello, Certificate, ServerHelloDone
        server_random = urandom(32)
        conn.sendall(build_server_hello(server_random))
        conn.sendall(build_certificate(cert_bytes))
        conn.sendall(build_server_hello_done())
        print("[*] Sent ServerHello, Certificate, ServerHelloDone")

        # recv ClientKeyExchange
        rec = conn.recv(8192)
        if not rec: return
        if rec[0] != 0x16: return
        body = rec[5:]
        enc_len = struct.unpack(">H", body[4:6])[0]
        encrypted = body[6:6+enc_len]

        # try decrypt
        try:
            premaster = priv_key.decrypt(encrypted, PKCS1v15())
        except Exception:
            print("[-] Bad PKCS#1 padding")
            conn.sendall(build_alert(21))  # bad padding
            return
        print("[+] Decrypted premaster")

        # recv ChangeCipherSpec
        change = conn.recv(4096)
        if not change or change[0] != 0x14:
            conn.sendall(build_alert(20))
            return

        # recv Finished
        finished = conn.recv(4096)
        if not finished or finished[0] != 0x16:
            conn.sendall(build_alert(20))
            return
        encrypted = finished[5:]

        # derive keys
        client_random = client_hello[11:43]
        master_secret = tls_prf(premaster, b"master secret", client_random+server_random, 48)
        key_block = tls_prf(master_secret, b"key expansion", server_random+client_random, 104)
        client_mac = key_block[:20]
        client_key = key_block[40:56]
        client_iv = key_block[72:88]

        # decrypt Finished
        cipher = Cipher(algorithms.AES(client_key), modes.CBC(client_iv), backend=default_backend())
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(encrypted) + decryptor.finalize()
        mac_input = b"\x00"*8 + b"\x16" + TLS_VERSION + struct.pack(">H", len(plaintext)-20) + plaintext[:-20]
        mac = hmac.new(client_mac, mac_input, sha1).digest()
        if mac != plaintext[-20:]:
            print("[-] Bad MAC")
            conn.sendall(build_alert(20)) # bad record MAC
            return
        print("[+] Valid MAC, handshake complete")

        conn.sendall(b"OK\n")

    finally:
        conn.close()

def main():
    with open(KEY_FILE, "rb") as f:
        priv_key = load_pem_private_key(f.read(), password=None)
    with open(CERT_FILE, "rb") as f:
        cert_bytes = f.read()

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(("0.0.0.0", 5001))
    sock.listen(5)
    print("[*] TLS Error-Oracle Server listening on 0.0.0.0:5001")

    while True:
        conn, addr = sock.accept()
        print(f"[*] Connection from {addr}")
        handle_client(conn, priv_key, cert_bytes)

if __name__ == "__main__":
    main()
