#!/usr/bin/env python3
import socket, struct, hmac
from os import urandom
from hashlib import md5, sha1
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

TLS_VERSION = b"\x03\x01"   # TLS 1.0
CIPHER_SUITE = b"\x00\x2f"  # TLS_RSA_WITH_AES_128_SHA
BLOCK_SIZE = 16
SEQUENCE_NUMBER = 3         # Finished is the 4th record

CERT_FILE = "server.crt"
KEY_FILE = "server.key"

# ---------------- PRF ----------------
def p_hash(hash_mod, secret: bytes, seed: bytes, size: int):
    result = b""
    A = seed
    while len(result) < size:
        A = hmac.new(secret, A, hash_mod).digest()
        result += hmac.new(secret, A + seed, hash_mod).digest()
    return result[:size]

def tls_prf(secret: bytes, label: bytes, seed: bytes, size: int) -> bytes:
    half = (len(secret) + 1) // 2
    s1, s2 = secret[:half], secret[-half:]
    md5_bytes = p_hash(md5, s1, label + seed, size)
    sha1_bytes = p_hash(sha1, s2, label + seed, size)
    return bytes(x ^ y for x, y in zip(md5_bytes, sha1_bytes))

# ---------------- TLS record helpers ----------------
def recv_tls_record(conn):
    header = conn.recv(5)
    if not header:
        return None, None
    ctype = header[0]
    length = struct.unpack(">H", header[3:5])[0]
    body = b""
    while len(body) < length:
        chunk = conn.recv(length - len(body))
        if not chunk:
            break
        body += chunk
    return ctype, body

def build_server_hello(server_random: bytes) -> bytes:
    session_id = b"\x00"
    comp_methods = b"\x01\x00"
    body = (b"\x02" +
            struct.pack(">I", 38 + 1 + 2 + 1)[1:] +
            TLS_VERSION + server_random + session_id + CIPHER_SUITE + comp_methods)
    return b"\x16" + TLS_VERSION + struct.pack(">H", len(body)) + body

def build_certificate(cert_bytes: bytes) -> bytes:
    cert_list = struct.pack(">I", len(cert_bytes))[1:] + cert_bytes
    all_certs = struct.pack(">I", len(cert_list))[1:] + cert_list
    body = b"\x0b" + struct.pack(">I", len(all_certs))[1:] + all_certs
    return b"\x16" + TLS_VERSION + struct.pack(">H", len(body)) + body

def build_server_hello_done() -> bytes:
    body = b"\x0e\x00\x00\x00"
    return b"\x16" + TLS_VERSION + struct.pack(">H", len(body)) + body

def build_alert(description: int) -> bytes:
    level = 2  # fatal
    payload = bytes([level, description])
    return b"\x15" + TLS_VERSION + struct.pack(">H", len(payload)) + payload

# ---------------- PKCS#1 v1.5 padding check ----------------
def check_pkcs1_v15(block: bytes) -> bytes | None:
    """
    Return the premaster if padding is valid, otherwise None.
    """
    if len(block) < 11 or block[0:2] != b"\x00\x02":
        return None
    try:
        sep_index = block.index(b"\x00", 2)
    except ValueError:
        return None
    if sep_index < 10:
        return None
    if any(b == 0 for b in block[2:sep_index]):
        return None
    return block[sep_index+1:]

# ---------------- Main TLS logic ----------------
def handle_client(conn, priv_key, cert_bytes):
    try:
        # ---- ClientHello ----
        ctype, body = recv_tls_record(conn)
        if ctype != 0x16 or body[0] != 0x01:
            return
        print("[*] Got ClientHello")
        client_random = body[6:38]

        # ---- Send ServerHello, Certificate, ServerHelloDone ----
        server_random = urandom(32)
        conn.sendall(build_server_hello(server_random))
        conn.sendall(build_certificate(cert_bytes))
        conn.sendall(build_server_hello_done())
        print("[*] Sent ServerHello, Certificate, ServerHelloDone")

        # ---- ClientKeyExchange ----
        ctype, body = recv_tls_record(conn)
        if ctype != 0x16 or body[0] != 0x10:
            return

        enc_len = struct.unpack(">H", body[4:6])[0]
        encrypted = body[6:6+enc_len]

        # Raw RSA decryption (manual)
        numbers = priv_key.private_numbers()
        d = numbers.d
        n = numbers.public_numbers.n
        c = int.from_bytes(encrypted, "big")
        m = pow(c, d, n)
        block = m.to_bytes(priv_key.key_size // 8, "big")

        # Manual PKCS#1 check
        premaster = check_pkcs1_v15(block)
        if premaster is None:
            print("[-] Bad PKCS#1 padding")
            conn.sendall(build_alert(21))
            return

        print("[+] Valid PKCS#1 padding, premaster extracted")

        # (Optional) Cryptography sanity check
        try:
            _ = priv_key.decrypt(encrypted, padding.PKCS1v15())
        except Exception:
            print("[!] cryptography disagrees with manual padding check")

        # ---- ChangeCipherSpec ----
        ctype, body = recv_tls_record(conn)
        if ctype != 0x14:
            conn.sendall(build_alert(20))
            return

        # ---- Finished ----
        ctype, body = recv_tls_record(conn)
        if ctype != 0x16:
            conn.sendall(build_alert(20))
            return
        encrypted_finished = body

        # ---- Derive keys ----
        master_secret = tls_prf(premaster, b"master secret", client_random+server_random, 48)
        key_block = tls_prf(master_secret, b"key expansion", server_random+client_random, 104)
        client_mac = key_block[:20]
        client_key = key_block[40:56]
        client_iv = key_block[72:88]

        # ---- Decrypt Finished ----
        cipher = Cipher(algorithms.AES(client_key), modes.CBC(client_iv), backend=default_backend())
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(encrypted_finished) + decryptor.finalize()

        # Remove padding
        pad_len = plaintext[-1] + 1
        hs_sig_plus_mac = plaintext[:-pad_len]

        verify_mac = hs_sig_plus_mac[-20:]
        hs_sig = hs_sig_plus_mac[:-20]

        mac_input = (SEQUENCE_NUMBER.to_bytes(8, "big") +
                     bytes([0x16]) + TLS_VERSION +
                     len(hs_sig).to_bytes(2, "big") + hs_sig)
        mac = hmac.new(client_mac, mac_input, sha1).digest()

        if mac != verify_mac:
            print("[-] Bad MAC")
            conn.sendall(build_alert(20))
            return

        print("[+] Valid MAC, handshake complete")
        conn.sendall(b"OK\n")

    finally:
        conn.close()

def main():
    with open(KEY_FILE, "rb") as f:
        priv_key = load_pem_private_key(f.read(), password=None)
    with open(CERT_FILE, "rb") as f:
        cert_bytes = f.read()

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(("0.0.0.0", 5001))
    sock.listen(5)
    print("[*] TLS Error-Oracle Server listening on 0.0.0.0:5001")

    while True:
        conn, addr = sock.accept()
        print(f"[*] Connection from {addr}")
        handle_client(conn, priv_key, cert_bytes)

if __name__ == "__main__":
    main()
