#!/usr/bin/env python3
import socket, struct, hmac
from os import urandom
from hashlib import md5, sha1
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

from TLS_helpers import *

CERT_FILE = "server.crt"
KEY_FILE = "server.key"


# PKCS#1 v1.5 padding check
def check_pkcs1_v15(block: bytes) -> bytes | None:
    """
    Return the premaster if padding is valid, otherwise None.
    """
    if len(block) < 11 or block[0:2] != b"\x00\x02":
        return None
    try:
        sep_index = block.index(b"\x00", 2)
    except ValueError:
        return None
    if sep_index < 10:
        return None
    if any(b == 0 for b in block[2:sep_index]):
        return None
    return block[sep_index+1:]


# Main TLS logic
def handle_client(conn, priv_key, cert_bytes):
    try:
        # ClientHello
        ctype, body = recv_tls_record(conn)
        if ctype != 0x16 or body[0] != 0x01:
            return
        print("[*] Got ClientHello")
        client_random = body[6:38]

        # Send ServerHello, Certificate, ServerHelloDone
        server_random = urandom(32)
        conn.sendall(build_server_hello(server_random))
        conn.sendall(build_certificate(cert_bytes))
        conn.sendall(build_server_hello_done())
        print("[*] Sent ServerHello, Certificate, ServerHelloDone")

        # ClientKeyExchange
        ctype, body = recv_tls_record(conn)
        if ctype != 0x16 or body[0] != 0x10:
            return

        enc_len = struct.unpack(">H", body[4:6])[0]
        encrypted = body[6:6+enc_len]

        # Raw RSA decryption (manual)
        numbers = priv_key.private_numbers()
        d = numbers.d
        n = numbers.public_numbers.n
        c = int.from_bytes(encrypted, "big")
        m = pow(c, d, n)
        block = m.to_bytes(priv_key.key_size // 8, "big")

        # Manual PKCS#1 check
        premaster = check_pkcs1_v15(block)
        if premaster is None:
            print("[*] Bad PKCS#1 padding")
            conn.sendall(build_alert(21))
            return

        print("[*] Valid PKCS#1 padding, premaster extracted")

        # Cryptography sanity check
        try:
            _ = priv_key.decrypt(encrypted, padding.PKCS1v15())
        except Exception:
            print("[*] cryptography disagrees with manual padding check")

        # ChangeCipherSpec
        ctype, body = recv_tls_record(conn)
        if ctype != 0x14:
            conn.sendall(build_alert(20))
            return

        # Finished
        ctype, body = recv_tls_record(conn)
        if ctype != 0x16:
            conn.sendall(build_alert(20))
            return
        encrypted_finished = body

        # Derive keys
        master_secret = tls_prf(premaster, b"master secret", client_random+server_random, 48)
        key_block = tls_prf(master_secret, b"key expansion", server_random+client_random, 104)
        client_mac = key_block[:20]
        client_key = key_block[40:56]
        client_iv = key_block[72:88]

        # Decrypt Finished
        cipher = Cipher(algorithms.AES(client_key), modes.CBC(client_iv), backend=default_backend())
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(encrypted_finished) + decryptor.finalize()

        # Remove padding
        pad_len = plaintext[-1] + 1
        hs_sig_plus_mac = plaintext[:-pad_len]

        verify_mac = hs_sig_plus_mac[-20:]
        hs_sig = hs_sig_plus_mac[:-20]

        mac_input = (SEQUENCE_NUMBER.to_bytes(8, "big") +
                     bytes([0x16]) + TLS_VERSION +
                     len(hs_sig).to_bytes(2, "big") + hs_sig)
        mac = hmac.new(client_mac, mac_input, sha1).digest()

        if mac != verify_mac:
            print("[*] Bad MAC")
            conn.sendall(build_alert(20))
            return

        print("[*] Valid MAC, handshake complete")
        conn.sendall(b"OK\n")

    finally:
        conn.close()


def main():
    with open(KEY_FILE, "rb") as f:
        priv_key = load_pem_private_key(f.read(), password=None)
    with open(CERT_FILE, "rb") as f:
        cert_bytes = f.read()

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(("0.0.0.0", 5001))
    sock.listen(5)
    print("[*] TLS Error-Oracle Server listening on 0.0.0.0:5001")

    while True:
        conn, addr = sock.accept()
        print(f"[*] Connection from {addr}")
        handle_client(conn, priv_key, cert_bytes)


if __name__ == "__main__":
    main()
