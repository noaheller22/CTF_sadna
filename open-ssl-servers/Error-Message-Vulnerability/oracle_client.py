#!/usr/bin/env python3
import argparse
import hmac
import struct
import socket
import base64
from hashlib import sha1, md5
from os import urandom

from Crypto.Cipher import AES

TLS_VERSION = b"\x03\x01"  # TLS 1.0
CIPHER_SUITE_ID = 0x002f   # TLS_RSA_WITH_AES_128_SHA
HOST = "nova.cs.tau.ac.il"
PORT = 5001
BLOCK_SIZE = 16
SEQUENCE_NUMBER = 3        # Finished is the 4th record

class Keys:
    def __init__(self, key_block: bytes):
        self.client_mac_key = key_block[:20]
        self.server_mac_key = key_block[20:40]
        self.client_write_key = key_block[40:56]
        self.server_write_key = key_block[56:72]
        self.client_initialization_vector = key_block[72:88]
        self.server_initialization_vector = key_block[88:104]

# ---------------- PRF ----------------
def p_hash(hash_mod, secret: bytes, seed: bytes, size: int):
    result = b""
    A = seed
    while len(result) < size:
        A = hmac.new(secret, A, hash_mod).digest()
        result += hmac.new(secret, A + seed, hash_mod).digest()
    return result[:size]

def tls_prf(secret: bytes, label: bytes, seed: bytes, size: int) -> bytes:
    half_length = (len(secret) + 1) // 2
    s1, s2 = secret[:half_length], secret[-half_length:]
    md5_bytes = p_hash(md5, s1, label + seed, size)
    sha1_bytes = p_hash(sha1, s2, label + seed, size)
    return bytes(x ^ y for x, y in zip(md5_bytes, sha1_bytes))

# ---------------- TLS helpers ----------------
def recv_full(sock, n):
    buf = b""
    while len(buf) < n:
        chunk = sock.recv(n - len(buf))
        if not chunk:
            raise RuntimeError("Socket closed")
        buf += chunk
    return buf

def recv_tls_message(sock: socket.socket):
    header = recv_full(sock, 5)
    ctype = header[0]
    length = struct.unpack(">H", header[3:5])[0]
    body = recv_full(sock, length)
    return ctype, body

def derive_keys(master_secret: bytes, client_random: bytes, server_random: bytes) -> Keys:
    key_block = tls_prf(master_secret, b"key expansion", server_random + client_random, 104)
    return Keys(key_block)

# ---------------- Message builders ----------------
def build_client_hello(client_random: bytes) -> bytes:
    session_id = b"\x00"
    cipher_suites = struct.pack(">H", CIPHER_SUITE_ID)
    compression_methods = b"\x01\x00"
    message_body = TLS_VERSION + client_random + session_id + struct.pack(">H", len(cipher_suites)) + cipher_suites + compression_methods
    handshake = b"\x01" + struct.pack(">I", len(message_body))[1:] + message_body
    return b"\x16" + TLS_VERSION + struct.pack(">H", len(handshake)) + handshake

def build_client_key_exchange(ciphertext: bytes) -> bytes:
    body = struct.pack(">H", len(ciphertext)) + ciphertext
    handshake = b"\x10" + struct.pack(">I", len(body))[1:] + body
    return b"\x16" + TLS_VERSION + struct.pack(">H", len(handshake)) + handshake

def build_change_cipher_spec() -> bytes:
    return b"\x14" + TLS_VERSION + struct.pack(">H", 1) + b"\x01"

def build_finished(master_secret: bytes, keys: Keys, prev_handshakes: bytes) -> bytes:
    handshake_hash = md5(prev_handshakes).digest() + sha1(prev_handshakes).digest()
    verify_data = tls_prf(master_secret, b"client finished", handshake_hash, 12)
    handshake_signature = b"\x14" + len(verify_data).to_bytes(3, "big") + verify_data
    mac_input = SEQUENCE_NUMBER.to_bytes(8, "big") + bytes([0x16]) + TLS_VERSION + len(handshake_signature).to_bytes(2, "big") + handshake_signature
    mac = hmac.new(keys.client_mac_key, mac_input, sha1).digest()
    plaintext = handshake_signature + mac
    pad_len = BLOCK_SIZE - (len(plaintext) % BLOCK_SIZE)
    if pad_len == BLOCK_SIZE:
        pad_len = 0
    if pad_len > 0:
        plaintext += bytes([pad_len - 1]) * pad_len
    cipher = AES.new(keys.client_write_key, AES.MODE_CBC, keys.client_initialization_vector)
    encrypted = cipher.encrypt(plaintext)
    return b"\x16" + TLS_VERSION + len(encrypted).to_bytes(2, "big") + encrypted

# ---------------- Server response parser ----------------
def receive_server_hello(sock: socket.socket):
    handshake = b""
    server_random = None
    while True:
        msg_type, body = recv_tls_message(sock)
        if msg_type != 22:  # handshake
            continue
        handshake += body
        if body[0] == 0x0e:  # ServerHelloDone
            break
        if body[0] == 0x02:  # ServerHello
            server_random = body[6:38]
    if server_random is None:
        raise SystemExit("Cannot find ServerHello")
    return server_random, handshake

def classify_server_response(sock: socket.socket):
    while True:
        data = sock.recv(4096)
        if not data:
            break
        if len(data) >= 7 and data[0] == 0x15:  # Alert
            desc = data[6]
            if desc == 20:
                return "Valid"
            elif desc == 21:
                return "Invalid"
        elif data == b"OK\n":
            return "OK"
    return "Unknown"

# ---------------- Main ----------------
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("ciphertext_b64", help="RSA ciphertext in base64")
    args = parser.parse_args()

    ciphertext = base64.b64decode(args.ciphertext_b64)
    client_random = urandom(32)

    client_hello = build_client_hello(client_random)
    client_key_exchange = build_client_key_exchange(ciphertext)
    change_cipher_spec = build_change_cipher_spec()

    sock = socket.create_connection((HOST, PORT))
    sock.sendall(client_hello)
    server_random, server_hello = receive_server_hello(sock)

    # Dummy premaster (not related to ciphertext)
    premaster = TLS_VERSION + urandom(46)
    master_secret = tls_prf(premaster, b"master secret", client_random + server_random, 48)
    keys = derive_keys(master_secret, client_random, server_random)

    all_handshakes = client_hello[5:] + server_hello + client_key_exchange[5:]
    finished = build_finished(master_secret, keys, all_handshakes)

    # Send messages
    sock.sendall(client_key_exchange)
    sock.sendall(change_cipher_spec)
    sock.sendall(finished)

    verdict = classify_server_response(sock)
    print(f"[Oracle verdict] {verdict}")

    sock.close()

if __name__ == "__main__":
    main()
