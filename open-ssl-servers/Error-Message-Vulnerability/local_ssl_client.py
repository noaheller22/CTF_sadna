import argparse
import hmac
import struct
import socket

from hashlib import sha1, md5
from os import urandom

from Crypto.Cipher import AES
from cryptography.hazmat.primitives.asymmetric.padding import PKCS1v15
from cryptography.hazmat.primitives.asymmetric.types import PublicKeyTypes
from cryptography.hazmat.primitives.serialization import load_pem_public_key


TLS_VERSION = b"\x03\x01"  # TLS 1.0
CIPHER_SUITE_ID = 0x002f   # TLS_RSA_WITH_AES_128_SHA
HOST = "nova.cs.tau.ac.il"
PORT = 5001
BLOCK_SIZE = 16            # 128 bit AES
SEQUENCE_NUMBER = 3        # Used after 3 records are sent (client hello, client key exchange, change cipher spec)


class Keys:
  def __init__(self, key_block: bytes):
    self.client_mac_key = key_block[:20]
    self.server_mac_key = key_block[20:40]
    self.client_write_key = key_block[40:56]
    self.server_write_key = key_block[56:72]
    self.client_initialization_vector = key_block[72:88]
    self.server_initialization_vector = key_block[88:104]


def load_public_key(path: str) -> PublicKeyTypes:
  with open(path, "rb") as f:
    key_data = f.read()
    public_key = load_pem_public_key(key_data)
  
  return public_key


def p_hash(hash_mod, secret: bytes, seed: bytes, size: int):
  result = b""

  hmac_seed = seed
  while len(result) < size:
    hmac_seed = hmac.new(secret, hmac_seed, hash_mod).digest()
    result += hmac.new(secret, hmac_seed + seed, hash_mod).digest()
  
  return result[:size]


def tls_prf(secret: bytes, label: bytes, seed: bytes, size: int) -> bytes:  
  half_length = (len(secret) + 1) // 2
  mda_secret, shaq_secret = secret[:half_length], secret[-half_length:]

  hashed_md5 = p_hash(md5, mda_secret, label + seed, size)
  hashed_sha1 = p_hash(sha1, shaq_secret, label + seed, size)

  return bytes(md5_byte ^ sha1_byte for md5_byte, sha1_byte in zip(hashed_md5, hashed_sha1))


def recv_full(sock, n):
  buffer = b""

  while len(buffer) < n:
    chunk = sock.recv(n - len(buffer))

    if not chunk:
      raise RuntimeError("Socket closed")
    
    buffer += chunk
  
  return buffer


def recv_tls_message(sock: socket.socket) -> tuple[bytes, bytes]:
  message_header = recv_full(sock, 5)

  message_type = message_header[0]
  message_length = struct.unpack(">H", message_header[3:5])[0]

  message_body = recv_full(sock, message_length)

  return message_type, message_body


def derive_keys(master_secret: bytes, client_random: bytes, server_random: bytes) -> Keys:
  key_block = tls_prf(master_secret, b"key expansion", server_random + client_random, 104)
  return Keys(key_block)


def build_client_hello(client_random: bytes) -> bytes:
  session_id = b"\x00"
  cipher_suites = struct.pack(">H", CIPHER_SUITE_ID)
  compression_methods = b"\x01\x00"

  message_body = TLS_VERSION + client_random + session_id + struct.pack(">H", len(cipher_suites)) + cipher_suites + compression_methods
  handshake = b'\x01' + struct.pack(">I", len(message_body))[1:] + message_body
  client_hello = b'\x16' + TLS_VERSION + struct.pack(">H", len(handshake)) + handshake

  return client_hello


def build_client_key_exchange(premaster: bytes, public_key: PublicKeyTypes) -> bytes:
  encrypted_premaster = public_key.encrypt(premaster, PKCS1v15())
  body = struct.pack(">H", len(encrypted_premaster)) + encrypted_premaster

  handshake = b'\x10' + struct.pack(">I", len(body))[1:] + body
  client_key_exchange = b'\x16' + TLS_VERSION + struct.pack(">H", len(handshake)) + handshake

  return client_key_exchange


def build_change_cipher_spec() -> bytes:
  return b'\x14' + TLS_VERSION + struct.pack(">H", 1) + b'\x01'


# def build_finished(master_secret: bytes, keys: Keys, prev_handshakes: bytes) -> bytes:
#   handshake_hash = md5(prev_handshakes).digest() + sha1(prev_handshakes).digest()

#   print(f"Handshake messages length: {len(handshake_hash)}")
#   print(f"Handshake hash: {handshake_hash}")

#   verify_data = tls_prf(master_secret, b"client finished", handshake_hash, 12)

#   handshake_signature = b'\x14' + len(verify_data).to_bytes(3, "big") + verify_data
#   mac_input = SEQUENCE_NUMBER.to_bytes(8, "big") + bytes([0x16]) + TLS_VERSION + len(handshake_signature).to_bytes(2, "big") + handshake_signature
#   mac = hmac.new(keys.client_mac_key, mac_input, sha1).digest()

#   plaintext = handshake_signature + mac

#   # pad_len = BLOCK_SIZE - (len(plaintext) % BLOCK_SIZE)
#   # plaintext += bytes([pad_len]) * pad_len

#   pad_len = BLOCK_SIZE - (len(plaintext) % BLOCK_SIZE)
#   if pad_len == BLOCK_SIZE:
#     pad_len = 0
#   plaintext += bytes([pad_len - 1]) * pad_len

#   cipher = AES.new(keys.client_write_key, AES.MODE_CBC, keys.client_initialization_vector)
#   encrypted = cipher.encrypt(plaintext)

#   message = b'\x16' + TLS_VERSION + len(encrypted).to_bytes(2, "big") + encrypted

#   print(f"Original plaintext length: {len(handshake_signature + mac)}")
#   print(f"Padding needed: {pad_len}")
#   print(f"Final plaintext length: {len(plaintext)}")
#   print(f"Encrypted length: {len(encrypted)}")
#   print(f"MAC input: {mac_input}")
#   print(f"Calculated MAC: {mac}")

#   return message

def build_finished(master_secret: bytes, keys: Keys, prev_handshakes: bytes) -> bytes:
    print(f"Client MAC key: {keys.client_mac_key}")
    print(f"Client write key: {keys.client_write_key}")
    print(f"Client IV: {keys.client_initialization_vector}")

    handshake_hash = md5(prev_handshakes).digest() + sha1(prev_handshakes).digest()
    verify_data = tls_prf(master_secret, b"client finished", handshake_hash, 12)
    
    handshake_signature = b'\x14' + len(verify_data).to_bytes(3, "big") + verify_data
    mac_input = SEQUENCE_NUMBER.to_bytes(8, "big") + bytes([0x16]) + TLS_VERSION + len(handshake_signature).to_bytes(2, "big") + handshake_signature
    mac = hmac.new(keys.client_mac_key, mac_input, sha1).digest()
    
    plaintext = handshake_signature + mac
    
    print(f"Handshake signature length: {len(handshake_signature)}")
    print(f"MAC length: {len(mac)}")
    print(f"Plaintext length before padding: {len(plaintext)}")
    
    pad_len = BLOCK_SIZE - (len(plaintext) % BLOCK_SIZE)
    print(f"Calculated padding length: {pad_len}")
    
    if pad_len == BLOCK_SIZE:
        pad_len = 0
    if pad_len > 0:
        padding_bytes = bytes([pad_len - 1]) * pad_len
        print(f"Padding bytes: {padding_bytes}")
        plaintext += padding_bytes
    
    print(f"Final plaintext length: {len(plaintext)}")
    print(f"Final plaintext: {plaintext}")
    
    cipher = AES.new(keys.client_write_key, AES.MODE_CBC, keys.client_initialization_vector)
    encrypted = cipher.encrypt(plaintext)
    
    message = b'\x16' + TLS_VERSION + len(encrypted).to_bytes(2, "big") + encrypted

    print(f"Sequence number: {SEQUENCE_NUMBER}")
    print(f"Content type: 0x16")  
    print(f"TLS version: {TLS_VERSION}")
    print(f"Handshake signature length: {len(handshake_signature)}")
    print(f"MAC input: {mac_input}")
    return message

def receive_server_hello(sock: socket.socket) -> tuple[bytes, bytes]:
  handshake = b""
  server_random = None

  while True:
    msg_type, body = recv_tls_message(sock)

    if msg_type != 22:  # handshake
      continue

    handshake += body

    if body[0] == 0x0e:  # ServerHelloDone
      break
    if body[0] == 0x02:  # ServerHello
      server_random = body[6:38]  # skip type(1) + length(3) 

  if server_random is None:
    raise SystemExit("Cannot find ServerHello")

  return server_random, handshake


def get_server_alert(sock: socket.socket):
  while True:
    try:
      data = sock.recv(4096)
    except Exception as e:
      print("No further server response:", e)
      break

    if not data:
      print("[DEBUG] Connection closed by server")
      break

    print(f"[DEBUG] Received {len(data)} bytes: {data}")

    if len(data) >= 7 and data[0] == 0x15:  # Alert
      level = data[5]
      description = data[6]
      levels = {1: "warning", 2: "fatal"}
      desc_map = {
        20: "Bad Record MAC",
        21: "Bad PKCS Padding",
      }
      print(f"TLS Alert: level={levels.get(level, level)}, "f"description={desc_map.get(description, description)}")


def main():
  parser = argparse.ArgumentParser()
  parser.add_argument("--public_key_path", required=True)
  args = parser.parse_args()

  public_key = load_public_key(args.public_key_path)
  client_random = urandom(32)
  premaster = TLS_VERSION + urandom(46)
  print("premaster:", premaster)

  client_hello = build_client_hello(client_random)
  client_key_exchange = build_client_key_exchange(premaster, public_key)
  change_cipher_spec = build_change_cipher_spec()

  sock = socket.create_connection((HOST, PORT))
  sock.sendall(client_hello)
  server_random, server_hello = receive_server_hello(sock) 

  master_secret = tls_prf(premaster, b"master secret", client_random + server_random, 48)
  print("master_secret:", master_secret)
  keys = derive_keys(master_secret, client_random, server_random)
  print(f"All handshake messages for hash: {(client_hello[5:] + server_hello + client_key_exchange[5:]).hex()}")

  finished = build_finished(master_secret, keys, client_hello[5:] + server_hello + client_key_exchange[5:])

  sock.sendall(client_key_exchange)
  sock.sendall(change_cipher_spec)
  sock.sendall(finished)

  print("Client Hello:", client_hello)
  print("Server Random:", server_random)
  print("Server Hello:", server_hello)
  print("Key Exchange:", client_key_exchange)
  print("Change Cipher:", change_cipher_spec)
  print("Finished:", finished)

  get_server_alert(sock)
  sock.close()


if __name__ == "__main__":
    main()
